---
title: "这里什么都没有..."
sitemap: false
permalink: /404.html
---

出现幻觉了吗？早点休息吧...

<body>
    <div class="game-container">
        <h1 class="game-title">扫雷游戏</h1>
        
        <div class="game-controls">
            <div class="difficulty-selector">
                <label for="difficulty">难度:</label>
                <select id="difficulty">
                    <option value="beginner">初级 (9×9, 10颗地雷)</option>
                    <option value="intermediate">中级 (16×16, 40颗地雷)</option>
                    <option value="expert">高级 (16×30, 99颗地雷)</option>
                </select>
            </div>
            
            <div class="game-status">
                <div class="status-item">
                    <div class="status-label">时间</div>
                    <div class="status-value" id="timer">0</div>
                </div>
                <div class="status-item">
                    <div class="status-label">剩余地雷</div>
                    <div class="status-value" id="mines-left">10</div>
                </div>
            </div>
        </div>
        
        <div class="game-board" id="game-board"></div>
    </div>
    
    <div class="game-over" id="game-over">
        <div class="game-over-message">
            <h2 class="game-over-title" id="game-result">游戏结束</h2>
            <p class="game-over-text" id="game-message"></p>
            <button class="restart-btn" id="restart-btn">重新开始</button>
        </div>
    </div>

    <script>
        // 游戏配置
        const difficultySettings = {
            beginner: { rows: 9, cols: 9, mines: 10 },
            intermediate: { rows: 16, cols: 16, mines: 40 },
            expert: { rows: 16, cols: 30, mines: 99 }
        };
        
        // 游戏状态变量
        let gameState = {
            board: [],
            mines: [],
            revealed: [],
            flagged: [],
            gameOver: false,
            gameWon: false,
            timer: 0,
            timerInterval: null,
            minesLeft: 0,
            firstClick: true
        };
        
        // DOM元素
        const gameBoard = document.getElementById('game-board');
        const timerDisplay = document.getElementById('timer');
        const minesLeftDisplay = document.getElementById('mines-left');
        const difficultySelect = document.getElementById('difficulty');
        const gameOverScreen = document.getElementById('game-over');
        const gameResult = document.getElementById('game-result');
        const gameMessage = document.getElementById('game-message');
        const restartBtn = document.getElementById('restart-btn');
        
        // 初始化游戏
        function initGame() {
            const difficulty = difficultySelect.value;
            const settings = difficultySettings[difficulty];
            
            // 重置游戏状态
            gameState = {
                board: [],
                mines: [],
                revealed: Array(settings.rows).fill().map(() => Array(settings.cols).fill(false)),
                flagged: Array(settings.rows).fill().map(() => Array(settings.cols).fill(false)),
                gameOver: false,
                gameWon: false,
                timer: 0,
                timerInterval: null,
                minesLeft: settings.mines,
                firstClick: true
            };
            
            // 更新显示
            timerDisplay.textContent = gameState.timer;
            minesLeftDisplay.textContent = gameState.minesLeft;
            
            // 创建游戏板
            createBoard(settings.rows, settings.cols);
            
            // 调整容器大小
            adjustContainerSize(settings.rows, settings.cols);
            
            // 清除游戏结束屏幕
            gameOverScreen.style.display = 'none';
        }
        
        // 创建游戏板
        function createBoard(rows, cols) {
            gameBoard.innerHTML = '';
            gameBoard.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            gameBoard.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
            
            // 初始化空板
            gameState.board = Array(rows).fill().map(() => Array(cols).fill(0));
            
            // 创建单元格
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    // 左键点击事件
                    cell.addEventListener('click', () => handleCellClick(i, j));
                    
                    // 右键点击事件
                    cell.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        handleRightClick(i, j);
                    });
                    
                    gameBoard.appendChild(cell);
                }
            }
        }
        
        // 调整容器大小
        function adjustContainerSize(rows, cols) {
            const container = document.querySelector('.game-container');
            const cellSize = window.innerWidth < 600 ? 25 : 30;
            const gapSize = 2;
            
            const boardWidth = cols * cellSize + (cols - 1) * gapSize;
            const boardHeight = rows * cellSize + (rows - 1) * gapSize;
            
            container.style.width = `${Math.max(boardWidth + 50, 350)}px`;
        }
        
        // 放置地雷（在第一次点击后）
        function placeMines(firstRow, firstCol, rows, cols, mines) {
            // 确保第一次点击不是地雷
            const safeCells = [];
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (Math.abs(i - firstRow) > 1 || Math.abs(j - firstCol) > 1) {
                        safeCells.push([i, j]);
                    }
                }
            }
            
            // 随机放置地雷
            for (let i = 0; i < mines; i++) {
                if (safeCells.length === 0) break;
                
                const randomIndex = Math.floor(Math.random() * safeCells.length);
                const [row, col] = safeCells.splice(randomIndex, 1)[0];
                
                gameState.mines.push([row, col]);
                gameState.board[row][col] = -1; // -1 表示地雷
                
                // 更新周围单元格的数字
                for (let r = Math.max(0, row - 1); r <= Math.min(rows - 1, row + 1); r++) {
                    for (let c = Math.max(0, col - 1); c <= Math.min(cols - 1, col + 1); c++) {
                        if (gameState.board[r][c] !== -1) {
                            gameState.board[r][c]++;
                        }
                    }
                }
            }
        }
        
        // 处理单元格点击
        function handleCellClick(row, col) {
            if (gameState.gameOver || gameState.flagged[row][col]) return;
            
            // 第一次点击时放置地雷
            if (gameState.firstClick) {
                const difficulty = difficultySelect.value;
                const settings = difficultySettings[difficulty];
                placeMines(row, col, settings.rows, settings.cols, settings.mines);
                gameState.firstClick = false;
                
                // 开始计时
                startTimer();
            }
            
            // 如果点击的是地雷
            if (gameState.board[row][col] === -1) {
                revealAllMines();
                gameState.revealed[row][col] = true;
                updateBoard();
                endGame(false);
                return;
            }
            
            // 揭示单元格
            revealCell(row, col);
            updateBoard();
            
            // 检查是否获胜
            if (checkWin()) {
                endGame(true);
            }
        }
        
        // 处理右键点击（标记旗帜）
        function handleRightClick(row, col) {
            if (gameState.gameOver || gameState.revealed[row][col]) return;
            
            gameState.flagged[row][col] = !gameState.flagged[row][col];
            gameState.minesLeft += gameState.flagged[row][col] ? -1 : 1;
            minesLeftDisplay.textContent = gameState.minesLeft;
            
            updateBoard();
        }
        
        // 揭示单元格（递归揭示空白区域）
        function revealCell(row, col) {
            if (gameState.revealed[row][col] || gameState.flagged[row][col]) return;
            
            gameState.revealed[row][col] = true;
            
            // 如果单元格是空白（值为0），递归揭示周围单元格
            if (gameState.board[row][col] === 0) {
                const difficulty = difficultySelect.value;
                const settings = difficultySettings[difficulty];
                
                for (let r = Math.max(0, row - 1); r <= Math.min(settings.rows - 1, row + 1); r++) {
                    for (let c = Math.max(0, col - 1); c <= Math.min(settings.cols - 1, col + 1); c++) {
                        if (!(r === row && c === col)) {
                            revealCell(r, c);
                        }
                    }
                }
            }
        }
        
        // 更新游戏板显示
        function updateBoard() {
            const difficulty = difficultySelect.value;
            const settings = difficultySettings[difficulty];
            
            for (let i = 0; i < settings.rows; i++) {
                for (let j = 0; j < settings.cols; j++) {
                    const cellIndex = i * settings.cols + j;
                    const cell = gameBoard.children[cellIndex];
                    
                    cell.className = 'cell';
                    
                    if (gameState.revealed[i][j]) {
                        cell.classList.add('revealed');
                        
                        if (gameState.board[i][j] === -1) {
                            cell.classList.add('mine');
                        } else if (gameState.board[i][j] > 0) {
                            cell.textContent = gameState.board[i][j];
                            cell.classList.add(`cell-${gameState.board[i][j]}`);
                        }
                    } else if (gameState.flagged[i][j]) {
                        cell.classList.add('flagged');
                    }
                }
            }
        }
        
        // 揭示所有地雷（游戏结束时）
        function revealAllMines() {
            const difficulty = difficultySelect.value;
            const settings = difficultySettings[difficulty];
            
            for (let i = 0; i < settings.rows; i++) {
                for (let j = 0; j < settings.cols; j++) {
                    if (gameState.board[i][j] === -1) {
                        gameState.revealed[i][j] = true;
                    }
                }
            }
        }
        
        // 开始计时器
        function startTimer() {
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
            }
            
            gameState.timerInterval = setInterval(() => {
                gameState.timer++;
                timerDisplay.textContent = gameState.timer;
            }, 1000);
        }
        
        // 检查是否获胜
        function checkWin() {
            const difficulty = difficultySelect.value;
            const settings = difficultySettings[difficulty];
            
            for (let i = 0; i < settings.rows; i++) {
                for (let j = 0; j < settings.cols; j++) {
                    // 如果有非地雷单元格未被揭示，则游戏未获胜
                    if (gameState.board[i][j] !== -1 && !gameState.revealed[i][j]) {
                        return false;
                    }
                }
            }
            
            return true;
        }
        
        // 结束游戏
        function endGame(isWin) {
            gameState.gameOver = true;
            gameState.gameWon = isWin;
            
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
            }
            
            // 显示游戏结束消息
            gameResult.textContent = isWin ? '恭喜！你赢了！' : '游戏结束';
            gameMessage.textContent = isWin 
                ? `你成功找到了所有地雷，用时 ${gameState.timer} 秒！` 
                : '你踩到了地雷，游戏失败。';
            
            gameOverScreen.style.display = 'flex';
        }
        
        // 事件监听器
        difficultySelect.addEventListener('change', initGame);
        restartBtn.addEventListener('click', initGame);
        
        // 初始化游戏
        initGame();
        
        // 窗口大小变化时调整游戏板
        window.addEventListener('resize', () => {
            const difficulty = difficultySelect.value;
            const settings = difficultySettings[difficulty];
            adjustContainerSize(settings.rows, settings.cols);
        });
    </script>
</body>
